<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon.png"><link rel="alternate" href="/atom.xml" title="Garen's Blog" type="application/atom+xml"><meta name="baidu-site-verification" content="true"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"7.5.0",exturl:!1,sidebar:{position:"left",width:300,display:"always",onmobile:!0,scrollpercent:!0},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:-1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"expandIn"}},translation:{copy_button:"Copy",copy_success:"Copied",copy_failure:"Copy failed"},sidebarPadding:40}</script><meta name="description" content="前言动态规划在 LeetCode 算法题库中占比例很大，目前相关标签的题目已经超过了两百道。对动态规划算法的使用贯穿全书，如股票系列问题中就有许多经典的应用，读者可以在将内容结合起来阅读。动态规划和其他算法思想如递归、回溯、分治和贪心等都有一定的联系，很多同学分不清楚这几者的关系，不知道该用什么方法。关于分治，贪心，回溯也会进行讲解，大家可以看完这几章内容之后对比思考它们之间的联系与差异。"><meta name="keywords" content="数据结构与算法,动态规划，LeetCode"><meta property="og:type" content="article"><meta property="og:title" content="【数据结构与算法】动态规划"><meta property="og:url" content="http:&#x2F;&#x2F;www.garenhou.com&#x2F;2020&#x2F;dynamic-programming&#x2F;index.html"><meta property="og:site_name" content="Garen&#39;s Blog"><meta property="og:description" content="前言动态规划在 LeetCode 算法题库中占比例很大，目前相关标签的题目已经超过了两百道。对动态规划算法的使用贯穿全书，如股票系列问题中就有许多经典的应用，读者可以在将内容结合起来阅读。动态规划和其他算法思想如递归、回溯、分治和贪心等都有一定的联系，很多同学分不清楚这几者的关系，不知道该用什么方法。关于分治，贪心，回溯也会进行讲解，大家可以看完这几章内容之后对比思考它们之间的联系与差异。"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http:&#x2F;&#x2F;www.garenhou.com&#x2F;2020&#x2F;dynamic-programming&#x2F;images&#x2F;10.2.1.1.jpg"><meta property="og:image" content="https:&#x2F;&#x2F;img.garenhou.com&#x2F;0082zybply1gc8sz1i7q8j30b4053mxa.jpg"><meta property="og:image" content="http:&#x2F;&#x2F;www.garenhou.com&#x2F;2020&#x2F;dynamic-programming&#x2F;assets&#x2F;10.3.1.jpg"><meta property="og:updated_time" content="2020-09-16T10:26:19.826Z"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http:&#x2F;&#x2F;www.garenhou.com&#x2F;2020&#x2F;dynamic-programming&#x2F;images&#x2F;10.2.1.1.jpg"><link rel="canonical" href="http://www.garenhou.com/2020/dynamic-programming/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><script>window.addEventListener('DOMContentLoaded', () => {
    'use strict';
    
      if (NexT.utils.hasMobileUA()) return;
    
    let time, hidden, visible, title = document.title;
    let favicon = document.querySelector('link[rel="icon"]');
    
      hidden = ["/･ω･｀) ~ U can run~","(っ °Д °;)っ ~ Oops, UFO caught this page..."];
      visible = ["ﾍ(･_| But U Never ESCAPE......garen's blog","(ง •̀_•́)ง  Got ya！！！"];
    
    let random = t => t[Math.floor(Math.random() * t.length)];
    const change = () => {
      if (document.hidden) {
        favicon.setAttribute('href', '/images/favicon/hidden.png');
        
          document.title = random(hidden);
        
        clearTimeout(time);
      } else {
        favicon.setAttribute('href', '/images/favicon/favicon.png');
        
          document.title = random(visible);
        
        time = setTimeout(() => {
          document.title = title;
        }, 3000);
      }
    }
    document.addEventListener('visibilitychange', change, false);
  });</script><title>【数据结构与算法】动态规划 | Garen's Blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Garen's Blog</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">Keep coding,Keep running</h1></div><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook" rel="section"><i class="fa fa-fw fa-commenting"></i>guestbook</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Searching..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a href="https://github.com/Garen2994" class="github-corner" title="Follow me" aria-label="Follow me" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans"><link itemprop="mainEntityOfPage" href="http://www.garenhou.com/2020/dynamic-programming/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar/avatar-admin.jpg"><meta itemprop="name" content="Garen Hou"><meta itemprop="description" content="碼渣渣 | 音樂雜食者 | 英美劇 | Brit-popper"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Garen's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">【数据结构与算法】动态规划</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2020-03-28 21:00:28" itemprop="dateCreated datePublished" datetime="2020-03-28T21:00:28+08:00">2020-03-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span> </a></span></span><span id="/2020/dynamic-programming/" class="post-meta-item leancloud_visitors" data-flag-title="【数据结构与算法】动态规划" title="Views"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine: </span><a title="valine" href="/2020/dynamic-programming/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2020/dynamic-programming/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fa fa-edit">Word count: </i></span><span>14k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="fa fa-clock-o">Time cost: </i></span><span>23 mins.</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>动态规划在 LeetCode 算法题库中占比例很大，目前相关标签的题目已经超过了两百道。对动态规划算法的使用贯穿全书，如股票系列问题中就有许多经典的应用，读者可以在将内容结合起来阅读。</p><p>动态规划和其他算法思想如递归、回溯、分治和贪心等都有一定的联系，很多同学分不清楚这几者的关系，不知道该用什么方法。关于分治，贪心，回溯也会进行讲解，大家可以看完这几章内容之后对比思考它们之间的联系与差异。</p><a id="more"></a><p>动态规划背后的基本思想是<code>穷举</code>，虽然看起来简单，如何涵盖所有的可能，并尽量减少重叠子问题的计算是一个难点。</p><p><strong>动态规划和递归</strong></p><p>介绍动态规划不得不提到递归，相较而言它更符合人的直觉，代码写起来也更简单。递归的缺点在于缩小问题规模的同时可能会进行大量的重复计算，通常我们可以通过存储中间结果来解决此问题，这种记忆化递归正是其与动态规划思想所共有的本质。递归是从原问题的目标场景倒推，逐步缩小问题规模，直到可解。而动态规划是从可解场景入手，逐步扩大规模到目标。</p><p><strong>动态规划与回溯</strong></p><p>动态规划往往用来处理最优解问题，而回溯往往用来计算所有的可能组合。和回溯法类似，动态规划的基础也是<code>穷举</code>所有可能，难点在于如何尽可能减少重叠子问题的计算。</p><p>例如 01 背包问题：</p><p>给定 N 个不同重量的物品，每一个物品的重量用一个数组 weight 维护，其中 weight[i] 表示第 i 个物品的重量，我们需要将其在不分割物品的情况下将其装入到一个容量大小为 V 的背包。背包可以装的物品最大值是多少？</p><p>那么如果用回溯法的话，会是什么样的呢？这里用伪代码让大家来感受一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(i, remain)</span>:</span></span><br><span class="line">    <span class="comment"># 装满了</span></span><br><span class="line">    <span class="keyword">if</span> i == n <span class="keyword">or</span> remain == <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> V - remain &gt; ans: ans = V - remain</span><br><span class="line">    <span class="comment"># 不装</span></span><br><span class="line">    f(i + <span class="number">1</span>, remain)</span><br><span class="line">    <span class="comment"># 还有空位</span></span><br><span class="line">    <span class="keyword">if</span> weight[i] &lt;= remian:</span><br><span class="line">        <span class="comment"># 装</span></span><br><span class="line">        f(i + <span class="number">1</span>, remain - weight[i])</span><br><span class="line">f(<span class="number">0</span>, V)</span><br></pre></td></tr></table></figure><p>这种回溯的方法穷举过程会有很多重复情况，复杂度是指数级别，大家可以参考图 1.3.2，读者也可以自己画递归树感受一下。</p><blockquote><p>回溯法优化点往往在于剪枝，避免走进根本不可能是结果的分支。</p></blockquote><p>使用动态规划求解，如何<code>穷举</code>所有可能呢？伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> to N:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span> to V + <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 装满了</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; weight[i]:</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="comment"># 还有空位</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j - weight[i]] + weight[i])</span><br></pre></td></tr></table></figure><p>动态规划相比较显得更“聪明”一些，它可以巧妙地利用之前计算过的结果集动态推导当前解，求解的时间复杂度是 $O(N * V)$。</p><p>区别于回溯法的暴力枚举，这种枚举方式是没有重复的。即上面代码产生的所有 (i, j) 的组合，并没有重复。这种不重复建立在<strong>巧妙地利用之前计算过的结果集</strong>，然而想用到之前计算过的结果集，就需要对问题进行分解。因此动态规划都会涉及到对原问题进行分解的过程。大致上，若要解决一个给定问题，我们需要解决其各个部分（即子问题），再根据子问题的解以得出原问题的解。</p><blockquote><p>小提示：是不是感觉有点像分治？大家可以结合 14 章的分治来理解动态规划哦。</p></blockquote><p><strong>动态规划的核心</strong></p><p>解决动态规划问题的核心就在于<code>找到状态转移方程</code>和<code>处理边界条件</code>。这两个中最为困难的当然是状态转移方程了，看出了状态转移方程，那么解题就是水到渠成的事情。对于某一道动态规划题目来说，状态转移方程可能不止一种，不同的状态转移方程对应不同的解法，而不同的转移方程性能差别有可能是巨大的，比如经典的 <code>887. 鸡蛋掉落 问题</code>。</p><p>那么如何找到状态转移方程呢？我们从画表格开始讲起。有经验的同学可能知道，很多动态规划问题都可以通过画表格来理解。这是为什么呢？</p><p>实际上所谓的表格就是 DP 数组，这个数组可能是一维的，可能是二维的，也可能是三维的，更高维度就很少见了。而表格就是 DP 数组的形象化表示。有的人不知道为什么动态规划要画表格，就觉得这个是必然的，必须要画表格才是动态规划。这是不对的，实际上<code>爬楼梯问题</code>就可以不用画表格就可以实现，而是借助两个额外的变量，但是前提是你要对画表格很熟悉，并掌握了一定的优化技巧，而这个技巧在这里指的是滚动数组，后面我们还会详细介绍。</p><p>其实正如前面所说，动态规划本质上是将大问题转化为小问题，并且大问题的解和小问题是有关联的，换句话说大问题的解可以由小问题的解计算得到。动态规划可以看作是一种类似查表的操作来缩短时间复杂度和空间复杂度的方法。</p><p>根本上说，画表格的目的是不断推导，完成状态转移，<strong>表格中的每一个 cell 都是一个小问题，填表的过程其实就是解决小问题的过程</strong>。先解决规模为寻常的情况，然后根据这个结果逐步推导，通常情况下，表格的右下角是问题的最大的规模，也就是我们想要求解的规模。但是这并不是绝对的，有时候是右上角，有时候也会是所有 cell 中的某一个。</p><p>还是以上面的背包问题为例，其实就是在不断在状态之间做选择，<strong>装</strong>还是<strong>不装</strong>，选择的标准就是哪种选择带来的价值更大。因此我们要做的就是对于选择和不选择两种情况分别求价值，然后取最大，最后更新 cell 即可。</p><p>其实大部分的动态规划问题套路都是“选择”和“不选择”，也就是一种“选择题”。并且大多数动态规划题目还伴随着空间上的优化，这是动态规划优于传统的记忆化递归的地方。除了这点，动态规划还可以减少递归产生的函数调用栈，因此性能上更好。</p><p>理论的东西比较抽象，下面我们通过几道具体的题目来消化下上面的知识。</p><h2 id="LC-70-爬楼梯"><a href="#LC-70-爬楼梯" class="headerlink" title="LC 70.爬楼梯"></a>LC 70.爬楼梯</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span><br><span class="line"></span><br><span class="line">每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span><br><span class="line"></span><br><span class="line">注意：给定 n 是一个正整数。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure><h3 id="解法一-动态规划"><a href="#解法一-动态规划" class="headerlink" title="解法一 动态规划"></a>解法一 动态规划</h3><p>对初学者来说，较为抽象、无法直接描述的算法一般会是学习的难点，需要更长的时间去消化和理解，例如初次接触递归，以及更难的动态规划。针对这些算法的学习，简单且经典的题目将是不可多得的宝贵材料。</p><p>本章的第一节，我们通过爬楼梯这道经典题目，开始动态规划算法的学习和实践。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>动态规划算法的本质是使用空间换时间，通过计算和记录状态来得到最优解。</p><p>先不用急着掌握理论，分析动态规划类题目时我们可以通过三个问题对题目进行基本的拆解:</p><ol><li>问题是否分阶段，<strong>阶段是什么</strong>？</li><li>与问题的最优解有关的<strong>子问题是什么</strong>？</li><li>透过不同阶段、最优解和子问题，我们应当关注（计算和记录）的<strong>状态</strong>具体是什么？</li></ol><p>前两个问题比较容易回答：</p><ul><li>爬楼梯是分阶段的，到达楼顶所需的 n 级台阶即对应 n 个阶段</li><li>题目的最优解是指最终到达楼顶时，有多少种不同方式；每个阶段都可以对应一个子问题，即有多少种不同的方法可以到达当前台阶</li></ul><p>关键点在于第三个问题。根据题目描述“每次你可以爬 1 或 2 个台阶”，这句话定义了状态之间的关联关系，决定了状态转移的规则。假设当前台阶为<code>n</code>，上述规则决定了我们可以两个阶段到达这里：从<code>n-1</code>台阶爬一步，或者从<code>n-2</code>台阶爬两步。因此到达台阶<code>n</code>可能的方法总数等于到达台阶<code>n-1</code>和台阶<code>n-2</code>的可能总数之和，这符合我们看到题目时马上会有的“直觉”，越往上走可能的走法越多。使用数组<code>dp</code>记录到达每一台阶可能的方法数，上述逻辑可以表示为<code>dp[i] = dp[i - 1] + dp[i - 2]</code>。通过这个状态转移函数，我们可以从 1 阶、 2 阶开始计算出到达 3 阶、 4 阶乃至 n 阶不同方法的总量。</p><p>下面的代码就是具体的实现过程。相比思考时的困难程度，动态规划类题目的具体实现较为简单明了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">1</span>], dp[<span class="number">2</span>] = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><p>(代码 10.1.1)<br><strong>复杂度分析</strong></p><ul><li>时间复杂度: $O(N)$，N 为台阶的数目；</li><li>空间复杂度: $O(N)$，N 为台阶的数目。</li></ul><h3 id="解法二-动态规划优化"><a href="#解法二-动态规划优化" class="headerlink" title="解法二 动态规划优化"></a>解法二 动态规划优化</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>观察解法一，每次计算用到的被记录状态都是<code>dp[i-1]</code>、<code>dp[i-2]</code>，除非有另外的需要，单纯计算最终解并不用保留中间过程的结果，<code>dp[i]</code>对<code>dp[i-1]</code>和<code>dp[i-2]</code>的依赖使用两个变量即可记录，例如定义变量<code>first</code>和<code>second</code>。</p><p>用常数个变量代替长度为 n 的线性存储结构的做法，使得空间复杂度由$O(N)$降低至$O(1)$，提高存储效率的同时执行效率也会得到提升。优化之后我们得到了下面的 python 代码：</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        first, second = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            second = first + second</span><br><span class="line">            first = second - first</span><br><span class="line">        <span class="keyword">return</span> second</span><br></pre></td></tr></table></figure><p>(代码 10.1.2)<br><strong>复杂度分析</strong></p><ul><li>时间复杂度: $O(N)$，N 为台阶的数目；</li><li>空间复杂度: $O(1)$。</li></ul><h2 id="打家劫舍系列"><a href="#打家劫舍系列" class="headerlink" title="打家劫舍系列"></a>打家劫舍系列</h2><p>“打家劫舍系列” 在 leetcode 当中总共有 3 道题，分别是：</p><ul><li><code>198. 打家劫舍</code>，简单难度级别</li><li><code>213. 打家劫舍 II</code>，中等难度级别</li><li><code>337. 打家劫舍 III</code>，中等难度级别</li></ul><p>而和动态规划相关的是前两道题。对于经验不太多的人，动态规划的解法往往不能够直接被想到。在 10.1 当中，我们已经基本熟悉了动态规划的基本构成，而本小节会进一步引导大家思考究竟是如何从暴力法演化到动态规划的。</p><h3 id="LC-198-打家劫舍"><a href="#LC-198-打家劫舍" class="headerlink" title="LC 198. 打家劫舍"></a>LC 198. 打家劫舍</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1：</p><p>输入：[1,2,3,1]</p><p>输出：4</p><p>解释：偷窃 1 号房屋 （金额 = 1) ，然后偷窃 3 号房屋 （金额 = 3)。<br>偷窃到的最高金额 = 1 + 3 = 4 。</p><h4 id="解法一-递归（超时）"><a href="#解法一-递归（超时）" class="headerlink" title="解法一 - 递归（超时）"></a>解法一 - 递归（超时）</h4><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>第一步，我们先从上面的题目描述中抽象出题意：</p><ul><li>从一个非负整数数组中找到一个子序列，并且该子序列的和最大</li><li>子序列中每个数的位置不能够相邻。举例来讲，如果子序列中包含位置为 1 的数，就不能包括位置为 2 的数。</li></ul><p>下面我们通过例图来更加深入的理解题意：<br><img src="./images/10.2.1.1.jpg" alt="10.2.1.1" title="图 10.2.1.1"><br>（图 10.2.1.1）</p><p>这里我们假设 $f(x), \ x \epsilon [0,n)$ 表示从位置 $x$ 到数组尾部的最大子序列和（这里的 $n$ 表示数组的长度）。通过上面草图 10.2.1.1 可以看出来：</p><ul><li>如果我们选取第一个数，那么问题就转换成 $x_0 + f(2)$ 的子问题</li><li>如果我们不选取第一个数，那么问题就转换成子问题 $f(1)$</li></ul><p>我们知道，如果一个大问题可以转换成独立的子问题，那么这个大问题就可以尝试使用递归的思路来解决。因此本题的递归写法就很容易被写出来。</p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.rob(nums[<span class="number">1</span>:]), nums[<span class="number">0</span>] + self.rob(nums[<span class="number">2</span>:]))</span><br></pre></td></tr></table></figure><p>（代码 10.2.1.1）</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：从图例 10.2.1.1 中我们可以看出时间复杂度为 $O(2^N)$ 级别，$N$ 是数组的长度。通常在算法题目中这种指数级别的复杂度是会超时的。因为普通的 1GHz 计算机每秒能够运算 $10^9$ 次，而 $2^{30} \approx 10^9$。也就是说，指数级复杂度不适合处理数据规模超过 $30$ 的数据（这里的 $30$ 只是个近似）。</li><li>空间复杂度：$O(N)$, $N$ 是数组的长度, 也就是递归调用栈的大小。</li></ul><h4 id="解法二-记忆化递归"><a href="#解法二-记忆化递归" class="headerlink" title="解法二 - 记忆化递归"></a>解法二 - 记忆化递归</h4><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>如果我们仔细分析上图，就会发现我们在递归调用子问题时会出现很多重复的子问题计算。很显然的想法就是将已经计算过的子问题结果保存起来以备后面使用。如此处理之后，我们在下一次遇到同样的子问题时直接返回结果就可以大大的降低计算的时间复杂度。</p><p>这种解题思路我们称为带“记忆”的递归调用（也被称为自顶向下的动态规划）：</p><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        memo = [<span class="number">-1</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(len(nums) + <span class="number">1</span>)]</span><br><span class="line">        memo[<span class="number">-1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="number">0</span>, nums, memo)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, n: int, nums: List[int], memo: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &gt;= len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> memo[n] != <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> memo[n]</span><br><span class="line"></span><br><span class="line">        memo[n] = max(</span><br><span class="line">            self.helper(n + <span class="number">1</span>, nums, memo),</span><br><span class="line">            self.helper(n + <span class="number">2</span>, nums, memo) + nums[n],</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br></pre></td></tr></table></figure><p>（代码 10.2.1.2）</p><p>上面的带“记忆”的递归调用，很明显的解决了重复子问题的计算。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N)$，$N$ 是数组的长度。</li><li>空间复杂度：$O(N)$，$N$ 是数组的长度。</li></ul><h4 id="解法三-动态规划"><a href="#解法三-动态规划" class="headerlink" title="解法三 - 动态规划"></a>解法三 - 动态规划</h4><h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>既然解法二被称为自顶向下（的解法），那么如果我们反过来思考，先得出最小子问题的解法，然后再得到最小子问题上面一层的子问题的解。这样一步步反过来-自底向上得到最初的解，是不是也可以呢？</p><p>显然这种解题思路是可行的。这种思路就是我们经常说的动态规划思想。</p><p>动态规划的第一步通常是找到对应的状态转移方程。由“记忆”的递归解法我们可以看到关键函数抽象出来就是： $helper(n) = max(helper(n+1), helper(n+2) + nums[n]$，而最终的结果就是 $helper(0)$。很明显，我们可以将 $helper(i), i \in [0, len(nums))$ 看成是一个个状态，然后最终结果可以由其他状态推导得出。</p><p>因此，下面的状态转移方程就可以很容易得出来：</p><script type="math/tex;mode=display">f(x) =
\begin{cases}
0,\ {x \geq n} \\
max(f(x+1), f(x+2) + nums[x]),\ {x < n}
\end{cases}</script><p>有了状态转移方程后，我们可以很容易得出下面的写法：</p><h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        memo = [<span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(len(nums) + <span class="number">1</span>)]</span><br><span class="line">        memo[<span class="number">-2</span>] = nums[<span class="number">-1</span>] <span class="comment"># 这里是为了避免下使用转移方程计算 memo[-2] 时 memo 数组溢出</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            memo[i] = max(memo[i + <span class="number">1</span>], memo[i + <span class="number">2</span>] + nums[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>（代码 10.2.1.3）</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N)$，$N$ 是数组的长度。</li><li>空间复杂度：$O(N)$，$N$ 是数组的长度。</li></ul><h4 id="解法四-空间优化的动态规划"><a href="#解法四-空间优化的动态规划" class="headerlink" title="解法四 - 空间优化的动态规划"></a>解法四 - 空间优化的动态规划</h4><h5 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h5><p><strong>很多时候，动态规划解法的空间复杂度是可以优化的。那么本题解法三是否能够优化呢？</strong><br>从状态转移方程可以知道状态 $f(n)$ 只依赖状态 $f(n-1)$ 和状态 $f(n-2)$。因此，额外的 $n$ 大小的辅助空间是不需要的。我们只需要两个额外的变量来表示两个依赖状态即可。</p><h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        prev = <span class="number">0</span></span><br><span class="line">        curr = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            temp = curr</span><br><span class="line">            curr = max(curr, nums[i] + prev)</span><br><span class="line">            prev = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure><p>（代码 10.2.1.4）</p><p>这里 prev 和 curr 被初始化为 0 （初始化时分别代表 $f(n+1)$ 和 $f(n)$，$n$ 是数组长度）。</p><p>从上而下，该题基本解决了，并且我们得出了解题思路的演化过程。而这一整套的思路演化过程对于一般的动态规划类型题目都是通用的（也就是我们所说的解题套路）。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N)$，$N$ 是数组的长度。</li><li>空间复杂度：$O(1)$。</li></ul><h3 id="LC-213-打家劫舍-II"><a href="#LC-213-打家劫舍-II" class="headerlink" title="LC 213. 打家劫舍 II"></a>LC 213. 打家劫舍 II</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>根据题意可知，该题在第一题的的基础上增加了一个条件，首尾的房屋是相连的，也就是说：</p><ul><li>如果偷了开头的房屋，那么结尾的房屋不能偷</li><li>如果偷了结尾的房屋，那么开头的房屋不能偷</li></ul><p>很明显，我们有了第一题的基础后，这一题的解题思路很好得到：<br>范围 $[0, n-1)$ 和范围 $[1,n)$ 中的较大值即为解，这里 $n$ 是数组的长度。</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        prev = <span class="number">0</span></span><br><span class="line">        curr = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">            temp = curr</span><br><span class="line">            curr = max(curr, nums[i] + prev)</span><br><span class="line">            prev = temp</span><br><span class="line"></span><br><span class="line">        res = curr</span><br><span class="line"></span><br><span class="line">        prev = <span class="number">0</span></span><br><span class="line">        curr = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            temp = curr</span><br><span class="line">            curr = max(curr, nums[i] + prev)</span><br><span class="line">            prev = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(res, curr)</span><br></pre></td></tr></table></figure><p>（代码 10.2.2.1）</p><p>这里唯一需要注意的边界情况是 nums 中只有一个元素。按照题目要求，nums 中只有一个元素的时候不会出现自环的情况。这时应该直接返回该元素值。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N)$，$N$ 是数组的长度。</li><li>空间复杂度：$O(1)$。</li></ul><h2 id="LC-62-不同路径"><a href="#LC-62-不同路径" class="headerlink" title="LC 62. 不同路径"></a>LC 62. 不同路径</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p><img src="https://img.garenhou.com/0082zybply1gc8sz1i7q8j30b4053mxa.jpg" alt=""></p><p>例如，上图是一个 7 x 3 的网格。有多少可能的路径？</p><p>说明：m 和 n 的值均不超过 100。</p><p>示例 1:</p><p>输入：m = 3, n = 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右<br>示例 2:</li></ol><p>输入：m = 7, n = 3<br>输出：28</p><h3 id="解法一-常规动态规划"><a href="#解法一-常规动态规划" class="headerlink" title="解法一 - 常规动态规划"></a>解法一 - 常规动态规划</h3><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>这是一道典型的适合使用动态规划解决的题目，它和爬楼梯等都属于动态规划中最简单的题目，因此也经常会被用于面试中的“开胃菜”。</p><p>如果你能想到动态规划的话，建立模型并解决也就不是难事。其实我们很容易看出，由于机器人只能右移动和下移动，因此到达格子 (i, j) 的路径数应该等于到达格子 (i - 1, j) 的路径数和到达格子 (i, j -1) 的路径数。如果用函数 f(i, j) 表示到达格子 (i, j) 的路径数，那么上述关系可以表示为<code>f(i, j) = f(i - 1, j) + f(i, j - 1)</code>。</p><p><img src="./assets/10.3.1.jpg" alt=""><br>（图 10.3.1）</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        d = [[<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                d[col][row] = d[col - <span class="number">1</span>][row] + d[col][row - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> d[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>（代码 10.3.1）</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(M * N)$</li><li>空间复杂度：$O(M * N)$</li></ul><h3 id="解法二-优化动态规划"><a href="#解法二-优化动态规划" class="headerlink" title="解法二 - 优化动态规划"></a>解法二 - 优化动态规划</h3><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>那么是否可以进一步优化呢？由于我们必须要将所有的元素遍历一次，因此时间复杂度是极限了。但还可以考虑优化空间复杂度。由于 dp[i][j] 只依赖于左边的元素和上面的元素，那么完全可以使用一个长度为 n 的一维数组 dp 来代替。当逐行扫描到 dp[i] 的时候，dp[i] 相当于二维数组的 dp[i - 1][j]，dp[i - 1] 相当于二维数组的 dp[i][j - 1]。因此空间复杂度得到了进一步优化，从 $O(M * N)$ 优化到 $O(N)$。如果你做过很多动态规划的题目的话，会发现这其实就是一个优化的信号，而面试中也很有可能让你优化空间复杂度，在这道题可以将 DP 数据进行降维处理，也就是从二维数组降低到一维数组。</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>（代码 10.3.2）</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(M * N)$</li><li>空间复杂度：$O(N)$</li></ul><h3 id="解法三-记忆化递归"><a href="#解法三-记忆化递归" class="headerlink" title="解法三 - 记忆化递归"></a>解法三 - 记忆化递归</h3><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>使用记忆化递归的方式来进行解题，由于需要开辟额外的栈内存，性能比上面的方法差不少。而且递归这种方法很容易导致栈溢出。写的递归程序如果递归太深，那么极有可能因为超过系统默认的递归深度限制而出现错误。不同的语言对于调用栈的深度限制是不同的，以 Python3 为例，一般默认最大递归深度在 1000 左右。我们也可以手动修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">1000000</span>)</span><br></pre></td></tr></table></figure><p>如上代码，将调用栈的深度限制在了 1000000。经测试，LeetCode 中 Python 的栈深度在 50006。 使用上面的代码最多可以设置到 226060 左右，超过之后会失效，并报<code>Runtime Error</code>的错。</p><p>然而也可以采用尾递归来进行优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。<a href="https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8" target="_blank" rel="noopener" title="尾调用">尾调用</a> 是指一个函数里的最后一个动作是返回一个函数的调用结果的情形，即最后一步新调用的返回值直接被当前函数的返回结果。 此时，该尾部调用位置被称为尾位置。尾调用中有一种重要而特殊的情形叫做尾递归。经过适当处理，尾递归形式的函数的运行效率可以被极大地优化。尾调用原则上都可以通过简化函数调用栈的结构而获得性能优化（称为“尾调用消除”），但是优化尾调用是否方便可行取决于运行环境对此类优化的支持程度如何。</p><p>如果不能采用上述两种方式(修改调用栈深度限制和尾递归)的话，那么就不得不根据算法本身，题目数据规模，以及语言自身的调用栈深度限制来考虑是否使用递归算法了。</p><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    visited = dict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> (m, n) <span class="keyword">in</span> self.visited:</span><br><span class="line">            <span class="keyword">return</span> self.visited[(m, n)]</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        cnt = self.uniquePaths(m - <span class="number">1</span>, n) + self.uniquePaths(m, n - <span class="number">1</span>)</span><br><span class="line">        self.visited[(m, n)] = cnt</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><p>（代码 10.3.3）</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(M * N)$</li><li>空间复杂度：$O(M * N)$</li></ul><blockquote><p>部分语言可能会超时</p></blockquote><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>你可以实现一个比 $O(M * N)$ 更快，比 $O(N)$ 更省内存的算法么？这里有一份 <a href="https://leetcode.com/articles/unique-paths/" target="_blank" rel="noopener" title="62. 不同路径 参考资料">资料</a> 可供参考。</p><blockquote><p>提示： 考虑数学</p></blockquote><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><h3 id="LC-322-零钱兑换"><a href="#LC-322-零钱兑换" class="headerlink" title="LC 322.零钱兑换"></a>LC 322.零钱兑换</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: coins = [1, 2, 5], amount = 11</span><br><span class="line">输出: 3</span><br><span class="line">解释: 11 = 5 + 5 + 1</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: coins = [2], amount = 3</span><br><span class="line">输出: -1</span><br><span class="line">说明:</span><br><span class="line">你可以认为每种硬币的数量是无限的。</span><br></pre></td></tr></table></figure><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>“计算可以凑成总金额所需的最少的硬币个数”是典型的求最优解问题，适合使用动态规划解决。沿用第一小节曾提到的三个基本问题分析题目：</p><ol><li>问题是否分阶段，<strong>阶段是什么</strong>？</li><li>与问题的最优解有关的<strong>子问题是什么</strong>？</li><li>透过不同阶段、最优解和子问题，我们应当关注（计算和记录）的<strong>状态</strong>具体是什么？</li></ol><p>总金额随着硬币的选取不断增加，不妨使用最小单位<code>1</code>分隔增加的过程。如此拆分出与总金额<code>amount</code>数量相当的阶段之后，问题似乎变得更“复杂”了。因为除数目较多之外，阶段之间并不一定逐一递进，假如没有一元硬币，可能有一些阶段是无法达到的。</p><p>情况确实是这样，阶段之间的关联取决于可用的硬币种类。假设硬币有两种：<code>1</code>和<code>5</code>，那么对于阶段<code>9</code>，它的前一个阶段可能是<code>8</code>加上一枚<code>1</code>元硬币，也可能是<code>4</code>加上一枚<code>5</code>元硬币。理解上述关系之后，为了使用尽量少的硬币，我们希望凑齐总金额前的阶段也使用尽量少的硬币。以此类推，到达每一阶段所需的最少硬币数就是我们应当记录的<strong>状态</strong>，如何计算（每个阶段所需最少的硬币数量）则是我们需要关注的<strong>子问题</strong>。</p><p>取数组<code>dp</code>记录到达各阶段所需最少硬币数，对于阶段<code>i</code>，其状态值<code>dp[i]</code>等于<code>dp[i - coin] + 1</code>，其中<code>coin</code>表示使用的硬币的面额；循环比较使用每种面额硬币所对应前一阶段（<code>i - coin</code>）的状态值，取其中最小的那个，使得<code>dp[i]</code>的值也最小。</p><p>从总金额为 1 开始，使用上面的方法逐阶段向后计算状态，最终得到凑成总金额所需的最少硬币数。每阶段计算时我们仅考虑每种硬币使用一次的情况，即比较<code>dp[i - coin] + 1</code>，而不涉及将硬币重复使用多次如<code>dp[i - coin * 2] + 2</code>等情况，这是因为我们采用顺序遍历所有阶段的方法，并且每一个阶段都会将所有可用的硬币考察一遍，因此前边阶段一种硬币使用多次的情况会在后边的阶段（如<code>i - coin</code>阶段）覆盖到。</p><p>为便于比较取较小值，初始化阶段我们将数组元素默认值设为大于最大可能硬币数，这里可以使用<code>amount + 1</code>；如果完成遍历所需硬币数仍为<code>amount + 1</code>，可以认为没有方法能够凑出这个金额，返回 -1 。下面是 python 代码实现。</p><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> amount == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 这里使用 amount + 1 这个值表示大于任何可能出现的值，方便初始的比较</span></span><br><span class="line">        dp = [amount + <span class="number">1</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, amount + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">                <span class="keyword">if</span> coin &lt;= i:</span><br><span class="line">                    dp[i] = min(dp[i], dp[i - coin] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> dp[amount] == (amount + <span class="number">1</span>) <span class="keyword">else</span> dp[amount]</span><br></pre></td></tr></table></figure><p>(代码 10.4.1)</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 使用了双层循环求解，因此时间复杂度为$O(M*N)$，其中 N 是<code>amount</code>的值，M 为<code>coins</code>的种类数。</li><li>空间复杂度：$O(N)$， 其中 N 是<code>amount</code>的值。</li></ul><h3 id="LC-518-零钱兑换-II"><a href="#LC-518-零钱兑换-II" class="headerlink" title="LC 518.零钱兑换 II"></a>LC 518.零钱兑换 II</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: amount = 5, coins = [1, 2, 5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有四种方式可以凑成总金额:</span><br><span class="line">5=5</span><br><span class="line">5=2+2+1</span><br><span class="line">5=2+1+1+1</span><br><span class="line">5=1+1+1+1+1</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">入: amount = 3, coins = [2]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 只用面额2的硬币不能凑成总金额3。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: amount = 10, coins = [10]</span><br><span class="line">输出: 1</span><br><span class="line"> </span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">你可以假设：</span><br><span class="line">- 0 &lt;= amount (总金额) &lt;= 5000</span><br><span class="line">- 1 &lt;= coin (硬币面额) &lt;= 5000</span><br><span class="line">- 硬币种类不超过 500 种</span><br><span class="line">- 结果符合 32 位符号整数</span><br></pre></td></tr></table></figure><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>这道题目是上题的变体，不同之处在于关注点变为硬币组合数，我们关注的子问题相应变化，不妨继续使用长度为<code>amount + 1</code>的数组<code>dp</code>记录状态值，并将可能组合数的默认值设为 0。</p><p>分析题目给出的第一个例子，假设仅有面值为 1 的硬币，凑成任意元有几种可能呢？答案很简单，只有一种。下面的图表表示了凑成 1 到 6 元分别的可能组合数。</p><div class="table-container"><table><thead><tr><th>凑成金额</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>可能组合数(使用 1)</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>这种场景意义不大，如果再多一种面额的硬币，比如<code>2</code>呢？<br>上一题我们已经分析过，选硬币的情形下对于<code>dp[n]</code>，它的状态与<code>coin</code>值决定的前序状态<code>dp[n - coin]</code>相关联；因此多一种面额<code>coin</code>的硬币将会多一条凑成金额<code>n</code>的路径，从<code>n - coin</code>阶段跳跃过来。<code>dp[n]</code>因此将多出与后者的状态值相当数量的组合方式：<code>dp[n] += dp[n - coin]</code>。</p><p>需注意当金额与硬币面额相等时显然有且只有一种方法，<code>d[n - n]</code>即<code>dp[0]</code>的值应为 1。在原有图表的基础上完成加入硬币 2 之后的结果：</p><div class="table-container"><table><thead><tr><th>凑成金额</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>可能组合数(使用 1)</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>可能组合数(使用 1、2)</td><td>1</td><td>1</td><td><strong>2</strong></td><td><strong>2</strong></td><td><strong>3</strong></td><td><strong>3</strong></td><td><strong>4</strong></td></tr></tbody></table></div><ul><li>当 n 的值为 2 时， <code>dp[2] += dp[2 - 2]</code> 则<code>dp[2]</code>等于 2，除原有的 “1、1” 组合，增加了硬币 2 与原有金额 0 的组合，“2”；</li><li>当 n 的值为 3 时， <code>dp[3] += dp[3 - 2]</code> 则<code>dp[3]</code>等于 2，除“1、1、1”外，增加了硬币 2 与原有金额 1 的组合，“2，1”；</li><li>当 n 的值为 4 时， <code>dp[4] += dp[4 - 2]</code> 则<code>dp[4]</code>等于 3，除“1、1、1、1”外，增加了硬币 2 与原有金额 2 的组合，即“2、1、1”和“2、2”；</li><li>以此类推</li></ul><p>增加面额为 5 的硬币，大于等于 5 的金额状态又会有所增加，<code>dp</code>将变为如下的状态：</p><div class="table-container"><table><thead><tr><th>凑成金额</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>可能组合数(使用 1、2)</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>4</td></tr><tr><td>可能组合数(使用 1、2、5)</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td><strong>4</strong></td><td><strong>5</strong></td></tr></tbody></table></div><p>通过分析上述状态转移图表，我们可以总结出 dp 值变化的规律，即对每种面额的硬币， <code>dp[i] += dp[i - coin]</code>。</p><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount: int, coins: List[int])</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(coin, amount + <span class="number">1</span>):</span><br><span class="line">                dp[i] += dp[i - coin]</span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br></pre></td></tr></table></figure><p>(代码 10.4.2)<br><strong>复杂度分析</strong></p><ul><li>时间复杂度：使用了双层循环求解，因此时间复杂为$O(M*N)$，其中 N 是<code>amount</code>的值，M 为<code>coins</code>的种类数。</li><li>空间复杂度：$O(N)$， 其中 N 是<code>amount</code>的值。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>解动态规划类问题，分析过程是有章可循的，我们通过对<strong>阶段</strong>、<strong>子问题</strong>和<strong>状态</strong>的拆解基本可以得到解问题的框架。具体的求解过程一般可通过推导<strong>状态转移方程</strong>或填<strong>状态转移表</strong>这两种方式来帮助实现。</p><p>本小节的两道题目属于“完全背包”问题，对于其具体定义和场景不做展开，单看这两道题目我们就能发现：根据题目要求定义状态<code>dp</code>和更新的方法<code>func</code>后，遍历的过程如下有套路可循，即使用双层循环对每个阶段和可选背包及其权值进行计算和记录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> to N + <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span> to V + <span class="number">1</span>:</span><br><span class="line">        dp[j] = func(dp[j], dp[j - weight[i - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>例如 10.4.1 中，我们的目标是求“凑成总金额所需的最少的硬币个数”，因此状态更新的方法是取<code>dp[i] = min(dp[i], dp[i - coin] + 1)</code>；又如 10.4.2 中，<code>dp</code>存储的是总组合数，因此状态更新方法为<code>dp[i] += dp[i - coin]</code>。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>总的来说，动态规划问题一般用来求最值，核心难点在于看出状态转移方程，而看出状态转移方程的关键通常在于<code>画表格</code>和<code>做选择</code>。然而这里的做选择并不仅仅是从几个候选中选择一个，也可能从某几个中做一定的运算得出，比如上面的 62. 不同路径。前面已经分析了，其状态转移方程为<code>f(i, j) = f(i - 1, j) + f(i, j - 1)</code>，这就是从前面的两个状态中选择两个相加得出，这也是一种非常常见的套路，比如经典的爬楼梯问题。不过更为常见的是选择最大值或者最小值的情况，比如 198. 打家劫舍，其就是选择的最大值，状态转移方程为<code>dp[i] = max(dp[i + 1], dp[i + 2] + nums[i])</code>。再比如 322.零钱兑换，其就是选择最小值，状态转移方程为<code>dp[i] = min(dp[i], dp[i - coin] + 1)</code>。</p><p>递归和动态规划之间的演进关系，这个我们在<code>10.2 打家劫舍系列</code>中做了详细的介绍，大家可以找几个动态规划的题目并使用记忆化规划求解加深一下印象。动态规划问题通常伴随着滚动数组的技巧，从而在空间上达到更优，这正是其相对于查表的递归性能更好的原因之一。另外还有一个好处是动态规划避免了递归产生的额外调用栈的性能开销。</p><p>另外推荐两道题目：<code>139. 单词拆分</code> 和 <code>140. 单词拆分 II</code>，感受一下动态规划和回溯算法的相似性和不同点。</p></div><div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Garen Hou</li><li class="post-copyright-link"><strong>本文连接： </strong><a href="http://www.garenhou.com/2020/dynamic-programming/" title="【数据结构与算法】动态规划">http://www.garenhou.com/2020/dynamic-programming/</a></li><li class="post-copyright-license"><strong>版权信息： </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 数据结构与算法</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CLeetCode/" rel="tag"><i class="fa fa-tag"></i> 动态规划，LeetCode</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2020/jvm-dynamic-age-algorithm%20/" rel="next" title="JVM 之动态计算对象年龄的规则"><i class="fa fa-chevron-left"></i> JVM 之动态计算对象年龄的规则</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2020/jvm-tools-summary/" rel="prev" title="JVM 之 JDK 监控和故障处理工具总结">JVM 之 JDK 监控和故障处理工具总结 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments" id="comments"></div></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LC-70-爬楼梯"><span class="nav-text">LC 70.爬楼梯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法一-动态规划"><span class="nav-text">解法一 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#思路"><span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码"><span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法二-动态规划优化"><span class="nav-text">解法二 动态规划优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-1"><span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码-1"><span class="nav-text">代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打家劫舍系列"><span class="nav-text">打家劫舍系列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LC-198-打家劫舍"><span class="nav-text">LC 198. 打家劫舍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-1"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法一-递归（超时）"><span class="nav-text">解法一 - 递归（超时）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#思路-2"><span class="nav-text">思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码-2"><span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法二-记忆化递归"><span class="nav-text">解法二 - 记忆化递归</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#思路-3"><span class="nav-text">思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码-3"><span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法三-动态规划"><span class="nav-text">解法三 - 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#思路-4"><span class="nav-text">思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码-4"><span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法四-空间优化的动态规划"><span class="nav-text">解法四 - 空间优化的动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#思路-5"><span class="nav-text">思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码-5"><span class="nav-text">代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LC-213-打家劫舍-II"><span class="nav-text">LC 213. 打家劫舍 II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-2"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-6"><span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码-6"><span class="nav-text">代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LC-62-不同路径"><span class="nav-text">LC 62. 不同路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-3"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法一-常规动态规划"><span class="nav-text">解法一 - 常规动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-7"><span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码-7"><span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法二-优化动态规划"><span class="nav-text">解法二 - 优化动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-8"><span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码-8"><span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法三-记忆化递归"><span class="nav-text">解法三 - 记忆化递归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-9"><span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码-9"><span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展"><span class="nav-text">扩展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#零钱兑换"><span class="nav-text">零钱兑换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LC-322-零钱兑换"><span class="nav-text">LC 322.零钱兑换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-4"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-10"><span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码-10"><span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LC-518-零钱兑换-II"><span class="nav-text">LC 518.零钱兑换 II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-5"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路-11"><span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码-11"><span class="nav-text">代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-1"><span class="nav-text">总结</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Garen Hou" src="/images/avatar/avatar-admin.jpg"><p class="site-author-name" itemprop="name">Garen Hou</p><div class="site-description" itemprop="description">碼渣渣 | 音樂雜食者 | 英美劇 | Brit-popper</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">20</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i>RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Garen2994" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Garen2994" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/Garen2994" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;Garen2994" rel="noopener" target="_blank"><i class="fa fa-fw fa-copyright"></i>CSDN</a> </span><span class="links-of-author-item"><a href="https://weibo.com/garen2994" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;garen2994" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 观光链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://liaoxuefeng.com/" title="http:&#x2F;&#x2F;liaoxuefeng.com" rel="noopener" target="_blank">Liaoxuefeng</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">by garen.hou | </span><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">吉ICP备19001857号-1 </a><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="Symbols count total">共 93k 字</span></div><div class="run_time" style="text-align:center"><span id="timeDate">Loding...</span><span id="times">Wait a moment...</span><script>var now=new Date;function createtime(){var n=new Date("10/21/2018 02:31:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script><span>| ✧٩(ˊωˋ*)و✧</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user">本站访客数</i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span>人 </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye">本站总访问量</i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span> 次</span></span></div><script>function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.log('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            leancloudSelector(url).innerText = time;
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=NOhFP0wE5YxWCwSWhfsfI5cQ-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'NOhFP0wE5YxWCwSWhfsfI5cQ-gzGzoHsz',
            'X-LC-Key': '7P0VsiQHma5GaoR9RHWbtVGD',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        const localhost = /http:\/\/(localhost|127.0.0.1|0.0.0.0)/;
        if (localhost.test(document.URL)) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });</script></div></footer></div><script color="0,92,175" opacity="0.7" zindex="-2" count="100" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest-nomobile.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'NOhFP0wE5YxWCwSWhfsfI5cQ-gzGzoHsz',
    appKey: 'P0VsiQHma5GaoR9RHWbtVGD',
    placeholder: "Just go go",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"scale":1,"jsonPath":"/live2dw/assets/assets/haruto.model.json"},"display":{"superSample":2,"width":100,"height":150,"position":"right"},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.8},"log":false,"tagMode":false});</script></body></html>