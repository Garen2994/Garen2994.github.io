<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>Garen&#39;s Blog</title>
  
  <subtitle>Keep coding,Keep running</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.garenhou.com/"/>
  <updated>2020-08-16T12:51:11.733Z</updated>
  <id>http://www.garenhou.com/</id>
  
  <author>
    <name>Garen Hou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手动实现 Java NIO</title>
    <link href="http://www.garenhou.com/2020/java-NIO-implement/"/>
    <id>http://www.garenhou.com/2020/java-NIO-implement/</id>
    <published>2020-04-11T10:01:09.000Z</published>
    <updated>2020-08-16T12:51:11.733Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。&lt;/p&gt;&lt;p&gt;NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 &lt;code&gt;Socket&lt;/code&gt; 和 &lt;code&gt;ServerSocket&lt;/code&gt; 相对应的 &lt;code&gt;SocketChannel&lt;/code&gt; 和 &lt;code&gt;ServerSocketChannel&lt;/code&gt; 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java网络编程" scheme="http://www.garenhou.com/categories/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java网络模型" scheme="http://www.garenhou.com/tags/Java%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="NIO" scheme="http://www.garenhou.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>JVM 之常用的参数配置指北</title>
    <link href="http://www.garenhou.com/2020/jvm-opt-arguments/"/>
    <id>http://www.garenhou.com/2020/jvm-opt-arguments/</id>
    <published>2020-04-08T04:04:59.000Z</published>
    <updated>2020-08-16T12:59:15.227Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在本篇文章中，你将掌握最常用的 JVM 参数配置。比如下面提到了一些概念比如堆、GC等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://www.garenhou.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://www.garenhou.com/tags/JVM/"/>
    
      <category term="参数配置" scheme="http://www.garenhou.com/tags/%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>从源码看 ArrayList 扩容机制</title>
    <link href="http://www.garenhou.com/2020/ArrayList-expansion-source-code/"/>
    <id>http://www.garenhou.com/2020/ArrayList-expansion-source-code/</id>
    <published>2020-04-06T03:06:28.000Z</published>
    <updated>2020-08-18T12:02:01.892Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文章是从源码来分析 ArrayList 的扩容机制。下面先从ArrayList的构造方法源码引入。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.garenhou.com/categories/Java/"/>
    
      <category term="集合" scheme="http://www.garenhou.com/categories/Java/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="集合" scheme="http://www.garenhou.com/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="ArrayList" scheme="http://www.garenhou.com/tags/ArrayList/"/>
    
      <category term="源码" scheme="http://www.garenhou.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>JVM 之 JDK 监控和故障处理工具总结</title>
    <link href="http://www.garenhou.com/2020/jvm-tools-summary/"/>
    <id>http://www.garenhou.com/2020/jvm-tools-summary/</id>
    <published>2020-04-05T16:23:59.000Z</published>
    <updated>2020-08-15T13:22:03.609Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在学习 JVM 的过程中，为了监控虚拟机性能和更好地调优，用到了很多的工具，包括了命令行工具、可视化工具等，在这里加以总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://www.garenhou.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://www.garenhou.com/tags/JVM/"/>
    
      <category term="性能监控" scheme="http://www.garenhou.com/tags/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    
      <category term="命令" scheme="http://www.garenhou.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>JVM 之动态计算对象年龄的规则</title>
    <link href="http://www.garenhou.com/2020/jvm-dynamic-age-algorithm%20/"/>
    <id>http://www.garenhou.com/2020/jvm-dynamic-age-algorithm%20/</id>
    <published>2020-03-13T07:45:11.000Z</published>
    <updated>2020-08-15T13:22:11.421Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在学习JVM的过程中，发现一些文章在讲Java堆中对象从新生代晋升到老年代的年龄阈值，也就是对象提升( Promotion )规则没有交代得很清楚，这里就再来理解一下&lt;strong&gt;动态对象年龄计算规则&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://www.garenhou.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://www.garenhou.com/tags/JVM/"/>
    
      <category term="垃圾回收" scheme="http://www.garenhou.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>MySQL知识点总结</title>
    <link href="http://www.garenhou.com/2020/mysql-summary/"/>
    <id>http://www.garenhou.com/2020/mysql-summary/</id>
    <published>2020-03-09T02:33:07.000Z</published>
    <updated>2020-08-14T12:28:29.363Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;MySQL学习后整理的基础知识会汇总，可随时查看，做复习用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://www.garenhou.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://www.garenhou.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.garenhou.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="http://www.garenhou.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="计算机基础知识" scheme="http://www.garenhou.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构与算法】链表及相关问题</title>
    <link href="http://www.garenhou.com/2019/Structure-and-Algorithm-Linkedlist/"/>
    <id>http://www.garenhou.com/2019/Structure-and-Algorithm-Linkedlist/</id>
    <published>2019-10-25T07:35:22.000Z</published>
    <updated>2019-12-26T08:45:22.285Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img.garenhou.com/diagram.jpeg&quot; alt=&quot;链表&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;链表&lt;/strong&gt;(Linked list)相关算法题在面试中很常见，本文将详细介绍链表相对复杂的操作，并用Java语言实现，其中包括：建立带环链表（区别于循环链表）、判断链表是否带环，求得环入口结点及环的长度；判断两个链表是否相交、求得交点；查找倒数第K个结点；反转链表。在LeetCode和剑指Offer中出现的链表问题，基本基于这几个操作。（反正我是一文搞懂啦~）其他简单的操作实现在文后链接中。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;学习目的&lt;/strong&gt;：掌握链表相关操作，熟练使用&lt;strong&gt;双指针法&lt;/strong&gt;(快慢指针法)&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Structure and algorithm" scheme="http://www.garenhou.com/categories/Structure-and-algorithm/"/>
    
      <category term="Linked list" scheme="http://www.garenhou.com/categories/Structure-and-algorithm/Linked-list/"/>
    
    
      <category term="Structure and algorithm" scheme="http://www.garenhou.com/tags/Structure-and-algorithm/"/>
    
      <category term="Linked list" scheme="http://www.garenhou.com/tags/Linked-list/"/>
    
      <category term="Java" scheme="http://www.garenhou.com/tags/Java/"/>
    
  </entry>
  
</feed>
